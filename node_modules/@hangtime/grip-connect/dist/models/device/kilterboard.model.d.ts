import { Device } from "../device.model.js";
import type { IKilterBoard } from "../../interfaces/device/kilterboard.interface.js";
/**
 * For API level 2 and API level 3.
 * The first byte in the data is dependent on where the packet is in the message as a whole.
 * More details: https://github.com/1-max-1/fake_kilter_board
 */
export declare enum KilterBoardPacket {
    /** If this packet is in the middle, the byte gets set to 77 (M). */
    V2_MIDDLE = 77,
    /** If this packet is the first packet in the message, then this byte gets set to 78 (N). */
    V2_FIRST = 78,
    /** If this is the last packet in the message, this byte gets set to 79 (0). */
    V2_LAST = 79,
    /** If this packet is the only packet in the message, the byte gets set to 80 (P). Note that this takes priority over the other conditions. */
    V2_ONLY = 80,
    /** If this packet is in the middle, the byte gets set to 81 (Q). */
    V3_MIDDLE = 81,
    /** If this packet is the first packet in the message, then this byte gets set to 82 (R). */
    V3_FIRST = 82,
    /** If this is the last packet in the message, this byte gets set to 83 (S). */
    V3_LAST = 83,
    /** If this packet is the only packet in the message, the byte gets set to 84 (T). Note that this takes priority over the other conditions. */
    V3_ONLY = 84
}
/**
 * Extracted from placement_roles database table.
 */
export declare const KilterBoardPlacementRoles: {
    id: number;
    product_id: number;
    position: number;
    name: string;
    full_name: string;
    led_color: string;
    screen_color: string;
}[];
/**
 * Represents a Aurora Climbing device.
 * Kilter Board, Tension Board, Decoy Board, Touchstone Board, Grasshopper Board, Aurora Board, So iLL Board
 * {@link https://auroraclimbing.com}
 */
export declare class KilterBoard extends Device implements IKilterBoard {
    /**
     * UUID for the Aurora Climbing Advertising service.
     * This constant is used to identify the specific Bluetooth service for Kilter Boards.
     * @type {string}
     * @static
     * @readonly
     * @constant
     */
    static readonly AuroraUUID: string;
    /**
     * Maximum length of the message body for byte wrapping.
     * This value defines the limit for the size of messages that can be sent or received
     * to ensure proper byte wrapping in communication.
     * @type {number}
     * @private
     * @readonly
     * @constant
     */
    private static readonly messageBodyMaxLength;
    /**
     * Maximum length of the Bluetooth message chunk.
     * This value sets the upper limit for the size of individual Bluetooth messages
     * sent to and from the device to comply with Bluetooth protocol constraints.
     * @type {number}
     * @private
     * @readonly
     * @constant
     */
    private static readonly maxBluetoothMessageSize;
    constructor();
    /**
     * Calculates the checksum for a byte array by summing up all bytes ot hre packet in a single-byte variable.
     * @param data - The array of bytes to calculate the checksum for.
     * @returns The calculated checksum value.
     */
    private checksum;
    /**
     * Wraps a byte array with header and footer bytes for transmission.
     * @param data - The array of bytes to wrap.
     * @returns The wrapped byte array.
     */
    private wrapBytes;
    /**
     * Encodes a position into a byte array.
     * The lowest 8 bits of the position get put in the first byte of the group.
     * The highest 8 bits of the position get put in the second byte of the group.
     * @param position - The position to encode.
     * @returns The encoded byte array representing the position.
     */
    private encodePosition;
    /**
     * Encodes a color string into a numeric representation.
     * The rgb color, 3 bits for the R and G components, 2 bits for the B component, with the 3 R bits occupying the high end of the byte and the 2 B bits in the low end (hence 3 G bits in the middle).
     * @param color - The color string in hexadecimal format (e.g., 'FFFFFF').
     * @returns The encoded /compressed color value.
     */
    private encodeColor;
    /**
     * Encodes a placement (requires a 16-bit position and a 24-bit rgb color. ) into a byte array.
     * @param position - The position to encode.
     * @param ledColor - The color of the LED in hexadecimal format (e.g., 'FFFFFF').
     * @returns The encoded byte array representing the placement.
     */
    private encodePlacement;
    /**
     * Prepares byte arrays for transmission based on a list of climb placements.
     * @param {{ position: number; role_id: number }[]} climbPlacementList - The list of climb placements containing position and role ID.
     * @returns {number[]} The final byte array ready for transmission.
     */
    private prepBytesV3;
    /**
     * Splits a collection into slices of the specified length.
     * https://github.com/ramda/ramda/blob/master/source/splitEvery.js
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     */
    private splitEvery;
    /**
     * The kilter board only supports messages of 20 bytes
     * at a time. This method splits a full message into parts
     * of 20 bytes
     *
     * @param buffer
     */
    private splitMessages;
    /**
     * Sends a series of messages to a device.
     */
    private writeMessageSeries;
    /**
     * Configures the LEDs based on an array of climb placements.
     * @param {{ position: number; role_id: number }[]} config - Array of climb placements for the LEDs.
     * @returns {Promise<number[] | undefined>} A promise that resolves with the payload array for the Kilter Board if LED settings were applied, or `undefined` if no action was taken or for the Motherboard.
     */
    led: (config: {
        position: number;
        role_id: number;
    }[]) => Promise<number[] | undefined>;
}
