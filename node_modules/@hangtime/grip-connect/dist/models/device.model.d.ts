import { BaseModel } from "./../models/base.model.js";
import type { IDevice, Service } from "../interfaces/device.interface.js";
import type { ActiveCallback, NotifyCallback, WriteCallback } from "../interfaces/callback.interface.js";
import type { DownloadPacket } from "../interfaces/download.interface.js";
import type { Commands } from "../interfaces/command.interface.js";
export declare abstract class Device extends BaseModel implements IDevice {
    /**
     * Filters to identify the device during Bluetooth scanning.
     * Used to match devices that meet specific criteria such as name, service UUIDs, etc.
     * @type {BluetoothLEScanFilter[]}
     * @public
     * @readonly
     */
    readonly filters: BluetoothLEScanFilter[];
    /**
     * Array of services provided by the device.
     * Services represent functionalities that the device supports, such as weight measurement, battery information, or custom services.
     * @type {Service[]}
     * @public
     * @readonly
     */
    readonly services: Service[];
    /**
     * Reference to the `BluetoothDevice` object representing this device.
     * This is the actual device object obtained from the Web Bluetooth API after a successful connection.
     * @type {BluetoothDevice | undefined}
     * @public
     */
    bluetooth?: BluetoothDevice | undefined;
    /**
     * Object representing the set of commands available for this device.
     * These commands allow communication with the device to perform various operations such as starting measurements, retrieving data, or calibrating the device.
     * @type {Commands}
     * @public
     * @readonly
     */
    readonly commands: Commands;
    /**
     * The BluetoothRemoteGATTServer interface of the Web Bluetooth API represents a GATT Server on a remote device.
     * @type {BluetoothRemoteGATTServer | undefined}
     * @private
     */
    private server;
    /**
     * The last message written to the device.
     * @type {string | Uint8Array | null}
     * @protected
     */
    protected writeLast: string | Uint8Array | null;
    /**
     * Indicates whether the device is currently active.
     * @type {boolean}
     */
    protected isActive: boolean;
    /**
     * Configuration for threshold and duration.
     */
    private activeConfig;
    /**
     * Maximum mass recorded from the device, initialized to "0".
     * @type {string}
     * @protected
     */
    protected massMax: string;
    /**
     * Average mass calculated from the device data, initialized to "0".
     * @type {string}
     * @protected
     */
    protected massAverage: string;
    /**
     * Total sum of all mass data points recorded from the device.
     * Used to calculate the average mass.
     * @type {number}
     * @protected
     */
    protected massTotalSum: number;
    /**
     * Number of data points received from the device.
     * Used to calculate the average mass.
     * @type {number}
     * @protected
     */
    protected dataPointCount: number;
    /**
     * Array of DownloadPacket entries.
     * This array holds packets that contain data downloaded from the device.
     * @type {DownloadPacket[]}
     * @protected
     */
    protected downloadPackets: DownloadPacket[];
    /**
     * Represents the current tare value for calibration.
     * @type {number}
     */
    private tareCurrent;
    /**
     * Indicates whether the tare calibration process is active.
     * @type {boolean}
     */
    private tareActive;
    /**
     * Timestamp when the tare calibration process started.
     * @type {number | null}
     */
    private tareStartTime;
    /**
     * Array holding the samples collected during tare calibration.
     * @type {number[]}
     */
    private tareSamples;
    /**
     * Duration time for the tare calibration process.
     * @type {number}
     */
    private tareDuration;
    /**
     * Optional callback for handling write operations.
     * @callback NotifyCallback
     * @param {massObject} data - The data passed to the callback.
     * @type {NotifyCallback | undefined}
     * @protected
     */
    protected notifyCallback: NotifyCallback;
    /**
     * Optional callback for handling write operations.
     * @callback WriteCallback
     * @param {string} data - The data passed to the callback.
     * @type {WriteCallback | undefined}
     * @protected
     */
    protected writeCallback: WriteCallback;
    /**
     * Optional callback for handling write operations.
     * @callback ActiveCallback
     * @param {string} data - The data passed to the callback.
     * @type {ActiveCallback | undefined}
     * @protected
     */
    protected activeCallback: ActiveCallback;
    /**
     * Event listener for handling the 'gattserverdisconnected' event.
     * This listener delegates the event to the `onDisconnected` method.
     *
     * @private
     * @type {(event: Event) => void}
     */
    private onDisconnectedListener;
    /**
     * A map that stores notification event listeners keyed by characteristic UUIDs.
     * This allows for proper addition and removal of event listeners associated with each characteristic.
     *
     * @private
     * @type {Map<string, EventListener>}
     */
    private notificationListeners;
    constructor(device: Partial<IDevice>);
    /**
     * Sets the callback function to be called when the activity status changes,
     * and optionally sets the configuration for threshold and duration.
     *
     * This function allows you to specify a callback that will be invoked whenever
     * the activity status changes, indicating whether the device is currently active.
     * It also allows optionally configuring the threshold and duration used to determine activity.
     *
     * @param {ActiveCallback} callback - The callback function to be set. This function
     *                                      receives a boolean value indicating the new activity status.
     * @param {object} [options] - Optional configuration object containing the threshold and duration.
     * @param {number} [options.threshold=2.5] - The threshold value for determining activity.
     * @param {number} [options.duration=1000] - The duration (in milliseconds) to monitor the input for activity.
     * @returns {void}
     * @public
     *
     * @example
     * device.active((isActive) => {
     *   console.log(`Device is ${isActive ? 'active' : 'inactive'}`);
     * }, { threshold: 3.0, duration: 1500 });
     */
    active: (callback: ActiveCallback, options?: {
        threshold?: number;
        duration?: number;
    }) => void;
    /**
     * Checks if a dynamic value is active based on a threshold and duration.
     *
     * This function assesses whether a given dynamic value surpasses a specified threshold
     * and remains active for a specified duration. If the activity status changes from
     * the previous state, the callback function is called with the updated activity status.
     *
     * @param {number} input - The dynamic value to check for activity status.
     * @returns {Promise<void>} A promise that resolves once the activity check is complete.
     *
     * @example
     * await device.activityCheck(5.0);
     */
    protected activityCheck: (input: number) => Promise<void>;
    /**
     * Connects to a Bluetooth device.
     * @param {Function} [onSuccess] - Optional callback function to execute on successful connection. Default logs success.
     * @param {Function} [onError] - Optional callback function to execute on error. Default logs the error.
     * @public
     *
     * @example
     * device.connect(
     *   () => console.log("Connected successfully"),
     *   (error) => console.error("Connection failed:", error)
     * );
     */
    connect: (onSuccess?: () => void, onError?: (error: Error) => void) => Promise<void>;
    /**
     * Disconnects the device if it is currently connected.
     * - Removes all notification listeners from the device's characteristics.
     * - Removes the 'gattserverdisconnected' event listener.
     * - Attempts to gracefully disconnect the device's GATT server.
     * - Resets relevant properties to their initial states.
     * @returns {void}
     * @public
     *
     * @example
     * device.disconnect();
     */
    disconnect: () => void;
    /**
     * Converts the `downloadPackets` array into a CSV formatted string.
     * @returns {string} A CSV string representation of the `downloadPackets` data, with each packet on a new line.
     * @private
     *
     * @example
     * const csvData = device.downloadToCSV();
     * console.log(csvData);
     */
    private downloadToCSV;
    /**
     * Converts an array of DownloadPacket objects to a JSON string.
     * @returns {string} JSON string representation of the data.
     * @private
     *
     * @example
     * const jsonData = device.downloadToJSON();
     * console.log(jsonData);
     */
    private downloadToJSON;
    /**
     * Converts an array of DownloadPacket objects to an XML string.
     * @returns {string}  XML string representation of the data.
     * @private
     *
     * @example
     * const xmlData = device.downloadToXML();
     * console.log(xmlData);
     */
    private downloadToXML;
    /**
     * Exports the data in the specified format (CSV, JSON, XML) with a filename format:
     * 'data-export-YYYY-MM-DD-HH-MM-SS.{format}'.
     *
     * @param {('csv' | 'json' | 'xml')} [format='csv'] - The format in which to download the data.
     * Defaults to 'csv'. Accepted values are 'csv', 'json', and 'xml'.
     *
     * @returns {void} Initiates a download of the data in the specified format.
     * @private
     *
     * @example
     * device.download('json');
     */
    download: (format?: "csv" | "json" | "xml") => void;
    /**
     * Returns UUIDs of all services associated with the device.
     * @returns {string[]} Array of service UUIDs.
     * @protected
     *
     * @example
     * const serviceUUIDs = device.getAllServiceUUIDs();
     * console.log(serviceUUIDs);
     */
    protected getAllServiceUUIDs: () => string[];
    /**
     * Attempt to use ES module import rather than require.
     * This approach uses an async dynamic import for `webbluetooth`,
     * so we can fallback if `navigator.bluetooth` is unavailable.
     */
    protected getBluetooth(): Promise<Bluetooth | import("webbluetooth").Bluetooth>;
    /**
     * Retrieves the characteristic from the device's service.
     * @param {string} serviceId - The UUID of the service.
     * @param {string} characteristicId - The UUID of the characteristic.
     * @returns {BluetoothRemoteGATTCharacteristic | undefined} The characteristic, if found.
     * @protected
     *
     * @example
     * const characteristic = device.getCharacteristic('battery', 'level');
     * if (characteristic) {
     *   console.log('Characteristic found');
     * }
     */
    protected getCharacteristic: (serviceId: string, characteristicId: string) => BluetoothRemoteGATTCharacteristic | undefined;
    /**
     * Handles notifications received from a characteristic.
     * @param {BluetoothRemoteGATTCharacteristic} characteristic - The notification event.
     *
     * @example
     * device.handleNotifications(someCharacteristic);
     */
    protected handleNotifications: (characteristic: BluetoothRemoteGATTCharacteristic) => void;
    /**
     * Checks if a Bluetooth device is connected.
     * @returns {boolean} A boolean indicating whether the device is connected.
     * @public
     *
     * @example
     * if (device.isConnected()) {
     *   console.log('Device is connected');
     * } else {
     *   console.log('Device is not connected');
     * }
     */
    isConnected: () => boolean;
    /**
     * Sets the callback function to be called when notifications are received.
     * @param {NotifyCallback} callback - The callback function to be set.
     * @returns {void}
     * @public
     *
     * @example
     * device.notify((data) => {
     *   console.log('Received notification:', data);
     * });
     */
    notify: (callback: NotifyCallback) => void;
    /**
     * Handles the 'connected' event.
     * @param {Function} onSuccess - Callback function to execute on successful connection.
     * @public
     *
     * @example
     * device.onConnected(() => {
     *   console.log('Device connected successfully');
     * });
     */
    protected onConnected: (onSuccess: () => void) => Promise<void>;
    /**
     * Handles the 'disconnected' event.
     * @param {Event} event - The 'disconnected' event.
     * @public
     *
     * @example
     * device.onDisconnected(event);
     */
    protected onDisconnected: (event: Event) => void;
    /**
     * Reads the value of the specified characteristic from the device.
     * @param {string} serviceId - The service ID where the characteristic belongs.
     * @param {string} characteristicId - The characteristic ID to read from.
     * @param {number} [duration=0] - The duration to wait before resolving the promise, in milliseconds.
     * @returns {Promise<string | undefined>} A promise that resolves when the read operation is completed.
     * @public
     *
     * @example
     * const value = await device.read('battery', 'level', 1000);
     * console.log('Battery level:', value);
     */
    read: (serviceId: string, characteristicId: string, duration?: number) => Promise<string | undefined>;
    /**
     * Initiates the tare calibration process.
     * @param {number} duration - The duration time for tare calibration.
     * @returns {boolean} A boolean indicating whether the tare calibration was successful.
     * @public
     *
     * @example
     * const success = device.tare(5000);
     * if (success) {
     *   console.log('Tare calibration started');
     * } else {
     *   console.log('Tare calibration failed to start');
     * }
     */
    tare(duration?: number): boolean;
    /**
     * Apply tare calibration to the provided sample.
     * @param {number} sample - The sample to calibrate.
     * @returns {number} The calibrated tare value.
     * @protected
     *
     * @example
     * const calibratedSample = device.applyTare(rawSample);
     * console.log('Calibrated sample:', calibratedSample);
     */
    protected applyTare(sample: number): number;
    /**
     * Updates the timestamp of the last device interaction.
     * This method sets the updatedAt property to the current date and time.
     * @protected
     *
     * @example
     * device.updateTimestamp();
     * console.log('Last updated:', device.updatedAt);
     */
    protected updateTimestamp: () => void;
    /**
     * Writes a message to the specified characteristic of a Bluetooth device and optionally provides a callback to handle responses.
     * @param {string} serviceId - The service UUID of the Bluetooth device containing the target characteristic.
     * @param {string} characteristicId - The characteristic UUID where the message will be written.
     * @param {string | Uint8Array | undefined} message - The message to be written to the characteristic. It can be a string or a Uint8Array.
     * @param {number} [duration=0] - Optional. The time in milliseconds to wait before resolving the promise. Defaults to 0 for immediate resolution.
     * @param {WriteCallback} [callback=writeCallback] - Optional. A custom callback to handle the response after the write operation is successful.
     * @returns {Promise<void>} A promise that resolves once the write operation is complete.
     * @public
     * @throws {Error} Throws an error if the characteristic is undefined.
     *
     * @example
     * // Example usage of the write function with a custom callback
     * await Progressor.write("progressor", "tx", ProgressorCommands.GET_BATT_VLTG, 250, (data) => {
     *   console.log(`Battery voltage: ${data}`);
     * });
     */
    write: (serviceId: string, characteristicId: string, message: string | Uint8Array | undefined, duration?: number, callback?: WriteCallback) => Promise<void>;
}
